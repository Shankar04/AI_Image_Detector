# -*- coding: utf-8 -*-
"""Image_Identifier.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1wcERGi2oNxy9n4xSUtKArombHqH3tCZm
"""

import torch
import urllib.request
import matplotlib.pyplot as plt
from PIL import Image
from torchvision import transforms
from torchvision import models

print("Cuda Available: %s" %torch.cuda.is_available())

#setting the url used to retrieve the image of the animal
url = 'https://upload.wikimedia.org/wikipedia/commons/thumb/4/4d/Cat_November_2010-1a.jpg/1200px-Cat_November_2010-1a.jpg'

file_name = 'inputFile'
urllib.request.urlretrieve(url, file_name)

#creates a new Image object in Python using the open() function from the PIL.Image module.
#The open() function takes the file path of an image file as an argument and returns an Image object that can
#be further processed, such as resizing, cropping, filtering, or displaying the image.
img = Image.open('inputFile')

# Convert to RGB if needed in order to maintain a channel size of 3 instead of 4
if img.mode != 'RGB':
    img = img.convert('RGB')

plt.imshow(img)

preprocess = transforms.Compose([
    transforms.Resize(256),
    transforms.CenterCrop(224),
    transforms.ToTensor(),
    transforms.Normalize(
    mean=[0.485, 0.456, 0.406],
    std=[0.229, 0.224, 0.225])])

img_tensor = preprocess(img)
batch = img_tensor.unsqueeze(0)
print(batch.shape)



#creates an instance of the AlexNet deep learning model from the torchvision.models module and sets the pretrained parameter to True,
#indicating that the pre-trained weights for the model should be downloaded and used.
model = models.alexnet(pretrained= True)

#sets the device variable to 'cuda' if a GPU is available on the system, and to 'cpu' otherwise. This is a common way to
#check if a GPU is available and to use it for running deep learning models, as GPUs can significantly speed up the training
#process compared to CPUs. The device variable is then typically used to move the model and data to the appropriate device using
#the .to(device) method in PyTorch.
device = 'cuda' if torch.cuda.is_available() else 'cpu'

#sets the model to evaluation mode in PyTorch where the model disables any layers that behave differently
#during training, such as dropout and batch normalization, and uses the learned weights to make predictions on the test or
#validation data (prevent overfitting).
model.eval()

#moves the model parameters and buffers to the specified device in PyTorch.
model.to(device)

#runs the input batch of data through the model that has been previously moved to the specified device using the .to() method.
#The resulting output y is a tensor of predictions or activations that can be used to calculate the loss function
#and update the model parameters during training, or to make predictions on new unseen data during inference.
#The batch of data is typically preprocessed and formatted according to the input requirements of the specific deep learning model,
#such as resizing, normalizing, and transforming the image data. By passing the data to the specified device, the computations are
#performed using the optimized parallel processing capabilities of the GPU,
#resulting in faster and more efficient training and inference.
y = model(batch.to(device))

#printing the shape of the y tensor
#print(y.shape)


#computes the maximum value and index along the second dimension of the tensor y in PyTorch, which typically represents the
#class probabilities or scores predicted by the model. The resulting tensor y_max contains the highest probability or score
#for each input example in the batch, while the tensor index contains the index of the class with the highest probability
#or score. This is often used to make predictions on the input data during inference, or to calculate the accuracy and other evaluation
#metrics of the model. The index can be used to look up the corresponding class label in a predefined mapping or list of classes.
y_max, ind = torch.max(y,1)
index = ind.item()


#We now know index but we don’t know the class with index 211. We need to retrieve the class names from PyTorch’s site now.
url = 'https://pytorch.tips/imagenet-labels'
fname = 'imagenet_class_labels.txt'
urllib.request.urlretrieve(url, fname)

#opening this list we imported and printing out the animal at index
with open("imagenet_class_labels.txt") as f:
  classes = [line.strip() for line in f.readlines()]

#applies the softmax activation function to the tensor y along the second dimension using the PyTorch nn.functional library,
#which normalizes the predicted class probabilities to values between 0 and 1 that sum up to 1. The resulting tensor contains
#the probability distribution over the classes for each input example in the batch.

#The indexing [0] selects the first example in the batch, and the multiplication by 100 scales the probabilities to percentages.
probe = torch.nn.functional.softmax(y, dim=1)[0] * 100

print("\nAlexNet Top 5 Predictions:")
_, indices = torch.sort(y, descending=True)
for idx in indices[0][:5]:
  print(f"{classes[idx]}: {probe[idx].item():.1f}%")

#sorts the values of the tensor y in PyTorch in descending order along the second dimension,
#while preserving the indices of the original elements.

#The resulting tensor indices contains the indices of the elements in y in descending order,
#while the tensor y retains its original shape and values.

#This is often used to identify the top-k classes with the highest probabilities or scores predicted by the model,
#or to calculate other ranking or ordering metrics.

from torchvision.io import read_image
from torchvision.models import resnet50, ResNet50_Weights

image = Image.open('inputFile')

# Step 1: Initialize model with the best available weights
weights = ResNet50_Weights.DEFAULT
model = resnet50(weights=weights)
model.eval()

# Step 2: Initialize the inference transforms
preprocess = weights.transforms()

# Step 3: Apply inference preprocessing transforms
batch = preprocess(img).unsqueeze(0)

# Step 4: Use the model and print the predicted category
prediction = model(batch).squeeze(0).softmax(0)
class_id = prediction.argmax().item()
score = prediction[class_id].item()
category_name = weights.meta["categories"][class_id]

print("\nResNet50 Top Prediction:")
print(f"{category_name}: {100 * score:.1f}%")